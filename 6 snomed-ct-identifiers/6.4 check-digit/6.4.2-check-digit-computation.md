# Check digit computation

The [SCTID](../../appendices/appendix-b.-specification-reference-information/s/sctid-data-type.md) includes a check-digit, which is generated using Verhoeff's dihedral check. This section explains the algorithm used and includes sample source code for generating and checking the check-digit in Java Script and Microsoft Visual Basic.

## Verhoeff's Dihedral Group D5 Check

The mathematical description of this technique may appear complex but in practice it can be reduced to a pair of two-dimensional arrays, a single dimensional inverse array and a simple computational procedure. These three arrays are shown in the following tables.

* The first array contains the result of "Dihedral D5" multiplication;
* The second array consists of 8 rows of which two are defined while the rest are derived by applying the following formula: _F(i, j) = F(i - 1, F(1, j))_ ;
* The third array consists of a single row containing the inverse of the Dihedral D5 array it identifies the location of all the zero values in the first array.

Table 6.4.2-1: Results of Dihedral D5 multiplication

<figure><img src="../../.gitbook/assets/Image 11-08-2025 at 13.54.jpeg" alt=""><figcaption></figcaption></figure>



Table 6.4.2-2: The full array for Function F

\


<figure><img src="../../.gitbook/assets/Image 11-08-2025 at 13.56.jpeg" alt=""><figcaption></figcaption></figure>

Table 6.4.2-3: The Inverse D5 array

<figure><img src="../../.gitbook/assets/Image 11-08-2025 at 13.58.jpeg" alt=""><figcaption></figcaption></figure>

The identifier is checked by starting at the rightmost digit of the identifier (the check-digit itself) and proceeding to the left processing each digit as follows:

* _Check_ = ArrayDihedralD5 ( _Check_, ArrayFunctionF(( _Position_ Modulus 8), _Digit_ ))

_Check_ = the running value of the check-sum (starts at zero and modified by each step).

_Position_ = the position of the digit (counted from the right starting at zero).

_Digit_ = the value of the digit.

The final value of _Check_ should be zero. Otherwise the check has failed.

When calculating the check-digit the same process is applied with a minor variation:

* _Position_ is the position that the digit will have when the  check-digit has been appended.
* The final value of _Check_ is applied to the Inverse D5 array to find the correct check-digit.

Check-digit= _**ArrayInverseD5**_ ( _Check_ ).

## Sample Java Script for computing Verhoeff's Dihedral Check

{% hint style="info" %}
A live version of an HTML form and JavaScript is available in section [SNOMED CT Identifier Check](6.4.1-snomed-ct-identifier-check.md).
{% endhint %}

<details>

<summary><strong>HTML Code for Form Calling the JavaScript below</strong> Expand source</summary>

`<style>`

`p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}`

`span.s1 {color: #021da7}span.s2 {color: #f9975e}`

`span.s3 {color: #ff9450}`

`span.s4 {color: #ab4500}`

`span.s5 {color: #a7a400}`

`table {border-width: 6px; border-color: #0080ff; border-collapse: collapse; border-style: ridge;}`

`td {border-width: 3px; border-color: #0080ff; border-collapse: collapse; padding: 6px; border-style: ridge;}`

`</style>`

`<form` `action=""` `name="form">`&#x20;

&#x20;       `<table` `width="441">`

&#x20;       `<tr>`

&#x20;           `<td` `width="212"` `height="25"> Partial Identifier <br/>(without check-digit)&nbsp;`&#x20;

`</td>`

&#x20;           `<td` `width="115"` `height="25">`&#x20;

&#x20;              `<input` `name="num"` `size="18"/>`&#x20;

&#x20;          `</td>`

&#x20;           `<td` `width="92"` `height="25">`

&#x20;               `<input` `onclick="VerhoeffCompute()"` `type="button"` `value="Compute"/>`

`</td>`&#x20;

&#x20;     `</tr>`&#x20;

&#x20;      `<tr>`&#x20;

&#x20;          `<td` `width="212"` `height="35"> SNOMED CT Identifier </td>`

&#x20;           `<td` `width="115"` `height="35">                <input` `name="numcd"` `size="18"/>`&#x20;

&#x20;          `</td>`&#x20;

&#x20;          `<td` `width="92"` `height="35">                <input` `onclick="VerhoeffCheck()"` `type="button"` `value="Check"/>`

`</td>`

&#x20;       `</tr>`

&#x20;       `<tr>`&#x20;

&#x20;          `<td` `width="212"` `height="23"> Result of check&nbsp; </td>`

&#x20;           `<td` `width="115"` `height="23"` `colspan="2"` `id="out"> </td>`

&#x20;       `</tr>`&#x20;

&#x20;      `<tr>`&#x20;

&#x20;          `<td` `width="212"` `height="23"> Component type </td>`

&#x20;           `<td` `width="115"` `height="23"` `colspan="2"` `id="component"> </td>`

&#x20;       `</tr>`

&#x20;       `<tr>`

&#x20;           `<td` `width="212"` `height="23"> Namespace </td>`

&#x20;           `<td` `width="115"` `height="23"` `colspan="2"` `id="extnamespace"> </td>`

&#x20;       `</tr>`&#x20;

&#x20;  `</table>`&#x20;

&#x20;  `<p` `style="margin-left: 0; margin-right: 0"> This Verhoeff checking part of this code was based on a webpage at: </p>`

&#x20;   `<ul>`&#x20;

&#x20;      `<li>`&#x20;

&#x20;          `<a` `href="`[`http://www.augustana.ab.ca/~mohrj/algorithms/checkdigit.html`](http://www.augustana.ab.ca/~mohrj/algorithms/checkdigit.html)`">`                [`http://www.augustana.ab.ca/~mohrj/algorithms/checkdigit.html`](http://www.augustana.ab.ca/~mohrj/algorithms/checkdigit.html) `</a>`

&#x20;       `</li>`&#x20;

&#x20;  `</ul>`

`</form>`

</details>

<details>

<summary><strong>Java Script Code for SCTID Validation and Check-Digit Computation</strong></summary>

`var` `FnF = new` `Array();`   &#x20;

&#x20;     `FnF[0] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];`   &#x20;

&#x20;     `FnF[1] = [1, 5, 7, 6, 2, 8, 3, 0, 9, 4];`   &#x20;

&#x20;           `for` `( var` `i = 2; i < 8; i++ )`&#x20;

&#x20;   `{`         &#x20;

&#x20;                `FnF[i] = [,,,,,,,,,];`&#x20;

&#x20;      `for` `( var` `j = 0; j < 10; j++ )`       &#x20;

`FnF[i][j] = FnF[i - 1][FnF[1][j]];`&#x20;

&#x20;  `}`

`var` `Dihedral = new` `Array(   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],   [1, 2, 3, 4, 0, 6, 7, 8, 9, 5],   [2, 3, 4, 0, 1, 7, 8, 9, 5, 6],   [3, 4, 0, 1, 2, 8, 9, 5, 6, 7],   [4, 0, 1, 2, 3, 9, 5, 6, 7, 8],   [5, 9, 8, 7, 6, 0, 4, 3, 2, 1],   [6, 5, 9, 8, 7, 1, 0, 4, 3, 2],   [7, 6, 5, 9, 8, 2, 1, 0, 4, 3],   [8, 7, 6, 5, 9, 3, 2, 1, 0, 4],   [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] );`&#x20;

`var` `InverseD5 = new` `Array(0, 4, 3, 2, 1, 5, 6, 7, 8, 9 );`



`function` `VerhoeffCheck()`

&#x20;      `{`

&#x20;   `var` `check = 0;`

&#x20;   `var` `IdValue = document.form.numcd.value;`

`document.getElementById("out").innerText = "";`

`document.getElementById("out").setAttribute("style","color:red;");`

`document.getElementById("component").innerText ="Invalid partition";`

`document.getElementById("component").setAttribute("style","color:green;");`

`document.getElementById("extnamespace").innerText ="No namespace";`

`document.getElementById("extnamespace").setAttribute("style","color:red;");`

&#x20;`for` `( var` `i=IdValue.length-1; i >=0; i-- )`

`check = Dihedral[check][FnF[(IdValue.length-i-1) % 8][IdValue.charAt(i)]];`

&#x20;   `if` `( check != 0 ) { document.getElementById("out").innerText = "Check-digit ERROR"; }`

`else` `if`  `(IdValue.length < 6) {document.getElementById("out").innerText = "SCTID too short";}`

`else` `if`  `(IdValue.length > 18) {document.getElementById("out").innerText = "SCTID too long";}`

`else` `{document.getElementById("out").innerText = "Check-digit OK";`

`document.getElementById("out").setAttribute("style","color:green;");`

`switch` `(IdValue.substr(IdValue.length-3,2))`&#x20;

&#x20;  `{`&#x20;

&#x20;  `case` `"00":`

`document.getElementById("component").innerText ="Concept";        document.getElementById("extnamespace").innerText ="International";`

&#x20;       `break;`

&#x20;   `case` `"01":`

`document.getElementById("component").innerText ="Description";`

`document.getElementById("extnamespace").innerText ="International";`

&#x20;       `break;`

&#x20;   `case` `"02":`

`document.getElementById("component").innerText ="Relationship";`

`document.getElementById("extnamespace").innerText ="International";`

&#x20;       `break;`&#x20;

&#x20;  `case` `"03":`

`document.getElementById("component").innerText ="Subset (RF1)";`

`document.getElementById("extnamespace").innerText ="International";`

`break;`&#x20;

&#x20;  `case` `"04":`

`document.getElementById("component").innerText ="Cross Map Set (RF1)";`

`document.getElementById("extnamespace").innerText ="International";`

&#x20;       `break;`&#x20;

&#x20;  `case` `"05":`

`document.getElementById("component").innerText ="Cross Map Target (RF1)";`

`document.getElementById("extnamespace").innerText ="International";`

&#x20;       `break;`

&#x20;   `case` `"10":`

`document.getElementById("component").innerText ="Concept";        document.getElementById("extnamespace").innerText =IdValue.substr(IdValue.length-10,7);`

&#x20;       `break;`

&#x20;   `case` `"11":`

`document.getElementById("component").innerText ="Description";`

`document.getElementById("extnamespace").innerText =IdValue.substr(IdValue.length-10,7);`

`break;`

&#x20;   `case` `"12":`

`document.getElementById("component").innerText ="Relationship";`

`document.getElementById("extnamespace").innerText =IdValue.substr(IdValue.length-10,7);`

&#x20;       `break;`&#x20;

&#x20;  `case` `"13":`

`document.getElementById("component").innerText ="Subset (RF1)";`

`document.getElementById("extnamespace").innerText =IdValue.substr(IdValue.length-10,7);`

`break;`&#x20;

&#x20;  `case` `"14":`

`document.getElementById("component").innerText ="Cross Map Set (RF1)";`

`document.getElementById("extnamespace").innerText =IdValue.substr(IdValue.length-10,7);`

&#x20;       `break;`&#x20;

&#x20;  `case` `"15":`

`document.getElementById("component").innerText ="Cross Map Target (RF1)";`

`document.getElementById("extnamespace").innerText =IdValue.substr(IdValue.length-10,7);`

`break;`   &#x20;

`default:`

`document.getElementById("component").setAttribute("style","color:red;");                       }`   &#x20;

`if` `(document.getElementById("extnamespace").innerText=='International') {document.getElementById("extnamespace").setAttribute("style","color:green;");}    else` `if` `(IdValue.length>10) {document.getElementById("extnamespace").setAttribute("style","color:green;");}    else`  `{document.getElementById("extnamespace").innerText="Invalid Namespace";`

&#x20;   `}`

&#x20;   `}`

&#x20;   `}`

`function` `VerhoeffCompute( )`



&#x20;       `{`&#x20;

&#x20;  `var` `IdValue = document.form.num.value; var` `check = 0;`

`document.form.numcd.value= "";`

&#x20;   `for` `( var` `i = IdValue.length-1; i >=0; i-- )`

`check = Dihedral[check][FnF[(IdValue.length-i) % 8][IdValue.charAt(i)]];`

`document.form.numcd.value = document.form.num.value + InverseD5[check];`

`VerhoeffCheck();`

`document.getElementById("out").innerText = "Computed check-digit";`   &#x20;

`}`

</details>

## Sample Visual Basic for computing Verhoeff's Dihedral Check

<details>

<summary><strong>Visual Basic Code for Check-Digit Computation</strong> </summary>

Option Explicit\
Private Dihedral (9) As Variant\
Private FnF(7) As Variant\
Private InverseD5 As Variant\
Public Function VerhoeffCheck(ByVal IdValue As String) As Boolean\
'Check the supplied value and return true or false\
Dim tCheck As Integer, i As Integer\
VerhoeffArrayInit\
For i = Len(IdValue) To 1 Step -1\
tCheck = Dihedral(tCheck)(FnF((Len(IdValue) - i) Mod 8)(Val(Mid(IdValue, i, 1))))\
Next\
VerhoeffCheck = tCheck = 0\
End Function\
Public Function VerhoeffCompute(ByVal IdValue As String) As String\
'Compute the check digit and return the identifier complete with check-digit\
Dim tCheck As Integer, i As Integer\
VerhoeffArrayInit\
For i = Len(IdValue) To 1 Step -1\
tCheck = Dihedral(tCheck)(FnF((Len(IdValue) - i + 1) Mod 8)(Val(Mid(IdValue, i, 1))))\
Next\
VerhoeffCompute = IdValue & InverseD5(tCheck)\
End Function\
Private Sub VerhoeffArrayInit()\
'Create the arrays required\
Dim i As Integer, j As Integer\
'if already created exit here\
If VarType(InverseD5) >= vbArray Then Exit Sub\
'create the DihedralD5 array\
Dihedral(0) = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\
Dihedral(1) = Array(1, 2, 3, 4, 0, 6, 7, 8, 9, 5)\
Dihedral(2) = Array(2, 3, 4, 0, 1, 7, 8, 9, 5, 6)\
Dihedral(3) = Array(3, 4, 0, 1, 2, 8, 9, 5, 6, 7)\
Dihedral(4) = Array(4, 0, 1, 2, 3, 9, 5, 6, 7, 8)\
Dihedral(5) = Array(5, 9, 8, 7, 6, 0, 4, 3, 2, 1)\
Dihedral(6) = Array(6, 5, 9, 8, 7, 1, 0, 4, 3, 2)\
Dihedral(7) = Array(7, 6, 5, 9, 8, 2, 1, 0, 4, 3)\
Dihedral(8) = Array(8, 7, 6, 5, 9, 3, 2, 1, 0, 4)\
Dihedral(9) = Array(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\
'create the FunctionF array\
FnF(0) = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\
FnF(1) = Array(1, 5, 7, 6, 2, 8, 3, 0, 9, 4)\
'compute the rest of the FunctionF array\
For i = 2 To 7\
FnF (i) = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\
For j = 0 To 9\
FnF (i)(j) = FnF(i - 1)(FnF(1)(j))\
Next\
Next\
'Create the InverseD5 array\
InverseD5 = Array("0", "4", "3", "2", "1", "5", "6", "7", "8", "9")\
End Sub

</details>

## Reasons for using a check-digit

Although a user should rarely type the SCTID, experience suggests that from time to time this will happen. A user may also copy and paste an SCTID. There is a significant risk of errors in these processes and inclusion of a check-digit is intended to reduce the risk of such errors passing undetected. The choice of check-digit algorithm has been made to maximize the detection of common typographical errors. These have been analyzed by in a paper by J. Verhoeff ("Error Detecting Decimal Codes", _Mathematical Center Tract 29_ , The Mathematical Center, Amsterdam, 1969) and subsequently cited in Wagner and Putter, ("Error Detecting Decimal Digits", _CACM_ , Vol 32, No. 1, January 1989). These papers give a detailed categorization of the sorts of errors humans make in dealing with decimal numbers, based on a study of 12000 errors:

* single errors: a becomes b (60% to 95% of all errors).
* omitting or adding a digit (10% to 20%).
* adjacent transpositions: ab becomes ba (10% to 20%).
* twin errors: aa becomes bb (0.5% to 1.5%).
* jump transpositions: acb becomes bca (0.5% to 1.5%).
* jump twin errors: aca becomes bcb (below 1%).
* phonetic errors: a0 becomes 1a -similar pronunciation e.g. thirty or thirteen (0.5% to 1.5%).

In the explanations above, a is not equal to b, but c can be any decimal digit.

## A brief comparison of check-digit effectiveness

#### The IBM Check

The check-sums used for credit cards (the IBM check) picks up the most common errors but miss some adjacent transpositions and many jump transpositions. Assuming the pattern of errors described above, on average it will miss between 4% and 5% of expected errors.

#### The ISBN Check (Modulus 11)

The ISBN modulus 11 (used for UK NHS number) picks up more errors than the IBM checksum. Leaving 2% to 3% of errors undetected. However, it generates a check-sum value of 0 to 10 and thus cannot be represented as a single check-digit in about 9% of cases. The ISBN convention is to use "X" to represent the check-digit value 10 but this is incompatible with an Integer representation. The UK NHS number uses this check-sum but regards and number generating a check-sum of 10 as an invalid identifier. This approach could be applied to the SCTID but this would render 9% of possible values unusable in each partition and namespace. This would prevent a simple sequence of values from being allocated as the _item identifier_ within any namespace. More significantly the unusable _item identifier_ would differ in each namespace or partition and this would prevent simple transpositions of _item identifiers_ between partitions and namespaces.

Partitions could be a useful way of distinguishing developmental and released components and revising the partition and recalculating the check-digit would then be an elegant way to activate these components for a distribution version. It seems unwise to prevent future development and maintenance by using a check-sum that will prevent this.

#### Verhoeff's Check

Verhoeff's check catches all single errors, all adjacent transpositions, over 95% of twin errors, over 94% of jump transpositions and jump twin errors, and most phonetic errors. Therefore, like modulus 11, the Verhoeff check reduces the undetected error rate to 2% or 3%. Unlike modulus 11, it does this using a single decimal check-digit and without limiting the range of valid numbers.

The majority of the undetected errors with both modulus 11 and Verhoeff result from additions or omissions of digits. Any check-digit method is likely to miss 10% of such errors and since these comprise 10% to 20%. The Verhoeff scheme also misses four jump twin errors involving digits with a difference of 5 (i.e. 050 vs. 505, 161 vs. 616, 272 vs. 727, and 494 vs. 949).
